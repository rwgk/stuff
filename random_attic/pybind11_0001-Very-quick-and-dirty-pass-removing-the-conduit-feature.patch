From fa690d4d0ea33e9bf767e5e2652129e61da8bc21 Mon Sep 17 00:00:00 2001
From: "Ralf W. Grosse-Kunstleve" <rgrossekunst@nvidia.com>
Date: Fri, 22 Aug 2025 11:44:15 -0700
Subject: [PATCH] Very quick-and-dirty pass removing the conduit feature from
 the production code (UNTESTED)

---
 include/pybind11/conduit/README.txt           |  15 ---
 .../pybind11/conduit/pybind11_conduit_v1.h    | 116 ------------------
 include/pybind11/detail/cpp_conduit.h         |  75 -----------
 include/pybind11/detail/type_caster_base.h    |  38 ------
 include/pybind11/pybind11.h                   |   7 +-
 5 files changed, 2 insertions(+), 249 deletions(-)
 delete mode 100644 include/pybind11/conduit/README.txt
 delete mode 100644 include/pybind11/conduit/pybind11_conduit_v1.h
 delete mode 100644 include/pybind11/detail/cpp_conduit.h

diff --git a/include/pybind11/conduit/README.txt b/include/pybind11/conduit/README.txt
deleted file mode 100644
index 9a2c53ba..00000000
--- a/include/pybind11/conduit/README.txt
+++ /dev/null
@@ -1,15 +0,0 @@
-NOTE
-----
-
-The C++ code here
-
-** only depends on <Python.h> **
-
-and nothing else.
-
-DO NOT ADD CODE WITH OTHER EXTERNAL DEPENDENCIES TO THIS DIRECTORY.
-
-Read on:
-
-pybind11_conduit_v1.h — Type-safe interoperability between different
-                        independent Python/C++ bindings systems.
diff --git a/include/pybind11/conduit/pybind11_conduit_v1.h b/include/pybind11/conduit/pybind11_conduit_v1.h
deleted file mode 100644
index 6d5d0efc..00000000
--- a/include/pybind11/conduit/pybind11_conduit_v1.h
+++ /dev/null
@@ -1,116 +0,0 @@
-// Copyright (c) 2024 The pybind Community.
-
-/* The pybind11_conduit_v1 feature enables type-safe interoperability between
-
-* different independent Python/C++ bindings systems,
-
-* including pybind11 versions with different PYBIND11_INTERNALS_VERSION's.
-
-    * NOTE: The conduit feature
-            only covers    from-Python-to-C++ conversions, it
-            does not cover from-C++-to-Python conversions.
-            (For the latter, a different feature would have to be added.)
-
-The naming of the feature is a bit misleading:
-
-* The feature is in no way tied to pybind11 internals.
-
-* It just happens to originate from pybind11 and currently still lives there.
-
-* The only external dependency is <Python.h>.
-
-The implementation is a VERY light-weight dependency. It is designed to be
-compatible with any ISO C++11 (or higher) compiler, and does NOT require
-C++ Exception Handling to be enabled.
-
-Please see https://github.com/pybind/pybind11/pull/5296 for more background.
-
-The implementation involves a
-
-def _pybind11_conduit_v1_(
-    self,
-    pybind11_platform_abi_id: bytes,
-    cpp_type_info_capsule: capsule,
-    pointer_kind: bytes) -> capsule
-
-method that is meant to be added to Python objects wrapping C++ objects
-(e.g. pybind11::class_-wrapped types).
-
-The design of the _pybind11_conduit_v1_ feature provides two layers of
-protection against C++ ABI mismatches:
-
-* The first and most important layer is that the pybind11_platform_abi_id's
-  must match between extensions. — This will never be perfect, but is the same
-  pragmatic approach used in pybind11 since 2017
-  (https://github.com/pybind/pybind11/commit/96997a4b9d4ec3d389a570604394af5d5eee2557,
-  PYBIND11_INTERNALS_ID).
-
-* The second layer is that the typeid(std::type_info).name()'s must match
-  between extensions.
-
-The implementation below (which is shorter than this comment!), serves as a
-battle-tested specification. The main API is this one function:
-
-auto *cpp_pointer = pybind11_conduit_v1::get_type_pointer_ephemeral<YourType>(py_obj);
-
-It is meant to be a minimalistic reference implementation, intentionally
-without comprehensive error reporting. It is expected that major bindings
-systems will roll their own, compatible implementations, potentially with
-system-specific error reporting. The essential specifications all bindings
-systems need to agree on are merely:
-
-* PYBIND11_PLATFORM_ABI_ID (const char* literal).
-
-* The cpp_type_info capsule (see below: a void *ptr and a const char *name).
-
-* The cpp_conduit capsule (see below: a void *ptr and a const char *name).
-
-* "raw_pointer_ephemeral" means: the lifetime of the pointer is the lifetime
-  of the py_obj.
-
-*/
-
-// THIS MUST STAY AT THE TOP!
-#include "pybind11_platform_abi_id.h"
-
-#include <Python.h>
-#include <typeinfo>
-
-namespace pybind11_conduit_v1 {
-
-inline void *get_raw_pointer_ephemeral(PyObject *py_obj, const std::type_info *cpp_type_info) {
-    PyObject *cpp_type_info_capsule
-        = PyCapsule_New(const_cast<void *>(static_cast<const void *>(cpp_type_info)),
-                        typeid(std::type_info).name(),
-                        nullptr);
-    if (cpp_type_info_capsule == nullptr) {
-        return nullptr;
-    }
-    PyObject *cpp_conduit = PyObject_CallMethod(py_obj,
-                                                "_pybind11_conduit_v1_",
-                                                "yOy",
-                                                PYBIND11_PLATFORM_ABI_ID,
-                                                cpp_type_info_capsule,
-                                                "raw_pointer_ephemeral");
-    Py_DECREF(cpp_type_info_capsule);
-    if (cpp_conduit == nullptr) {
-        return nullptr;
-    }
-    void *raw_ptr = PyCapsule_GetPointer(cpp_conduit, cpp_type_info->name());
-    Py_DECREF(cpp_conduit);
-    if (PyErr_Occurred()) {
-        return nullptr;
-    }
-    return raw_ptr;
-}
-
-template <typename T>
-T *get_type_pointer_ephemeral(PyObject *py_obj) {
-    void *raw_ptr = get_raw_pointer_ephemeral(py_obj, &typeid(T));
-    if (raw_ptr == nullptr) {
-        return nullptr;
-    }
-    return static_cast<T *>(raw_ptr);
-}
-
-} // namespace pybind11_conduit_v1
diff --git a/include/pybind11/detail/cpp_conduit.h b/include/pybind11/detail/cpp_conduit.h
deleted file mode 100644
index a06b9b21..00000000
--- a/include/pybind11/detail/cpp_conduit.h
+++ /dev/null
@@ -1,75 +0,0 @@
-// Copyright (c) 2024 The pybind Community.
-
-#pragma once
-
-#include <pybind11/pytypes.h>
-
-#include "common.h"
-#include "internals.h"
-
-#include <typeinfo>
-
-PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
-PYBIND11_NAMESPACE_BEGIN(detail)
-
-// Forward declaration needed here: Refactoring opportunity.
-extern "C" inline PyObject *pybind11_object_new(PyTypeObject *type, PyObject *, PyObject *);
-
-inline bool type_is_managed_by_our_internals(PyTypeObject *type_obj) {
-#if defined(PYPY_VERSION)
-    auto &internals = get_internals();
-    return bool(internals.registered_types_py.find(type_obj)
-                != internals.registered_types_py.end());
-#else
-    return bool(type_obj->tp_new == pybind11_object_new);
-#endif
-}
-
-inline bool is_instance_method_of_type(PyTypeObject *type_obj, PyObject *attr_name) {
-    PyObject *descr = _PyType_Lookup(type_obj, attr_name);
-    return bool((descr != nullptr) && PyInstanceMethod_Check(descr));
-}
-
-inline object try_get_cpp_conduit_method(PyObject *obj) {
-    if (PyType_Check(obj)) {
-        return object();
-    }
-    PyTypeObject *type_obj = Py_TYPE(obj);
-    str attr_name("_pybind11_conduit_v1_");
-    bool assumed_to_be_callable = false;
-    if (type_is_managed_by_our_internals(type_obj)) {
-        if (!is_instance_method_of_type(type_obj, attr_name.ptr())) {
-            return object();
-        }
-        assumed_to_be_callable = true;
-    }
-    PyObject *method = PyObject_GetAttr(obj, attr_name.ptr());
-    if (method == nullptr) {
-        PyErr_Clear();
-        return object();
-    }
-    if (!assumed_to_be_callable && PyCallable_Check(method) == 0) {
-        Py_DECREF(method);
-        return object();
-    }
-    return reinterpret_steal<object>(method);
-}
-
-inline void *try_raw_pointer_ephemeral_from_cpp_conduit(handle src,
-                                                        const std::type_info *cpp_type_info) {
-    object method = try_get_cpp_conduit_method(src.ptr());
-    if (method) {
-        capsule cpp_type_info_capsule(const_cast<void *>(static_cast<const void *>(cpp_type_info)),
-                                      typeid(std::type_info).name());
-        object cpp_conduit = method(bytes(PYBIND11_PLATFORM_ABI_ID),
-                                    cpp_type_info_capsule,
-                                    bytes("raw_pointer_ephemeral"));
-        if (isinstance<capsule>(cpp_conduit)) {
-            return reinterpret_borrow<capsule>(cpp_conduit).get_pointer();
-        }
-    }
-    return nullptr;
-}
-
-PYBIND11_NAMESPACE_END(detail)
-PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
diff --git a/include/pybind11/detail/type_caster_base.h b/include/pybind11/detail/type_caster_base.h
index 1b23c5c6..4e508433 100644
--- a/include/pybind11/detail/type_caster_base.h
+++ b/include/pybind11/detail/type_caster_base.h
@@ -14,7 +14,6 @@
 #include <pybind11/trampoline_self_life_support.h>
 
 #include "common.h"
-#include "cpp_conduit.h"
 #include "descr.h"
 #include "dynamic_raw_ptr_cast_if_possible.h"
 #include "internals.h"
@@ -1010,13 +1009,6 @@ public:
         }
         return false;
     }
-    bool try_cpp_conduit(handle src) {
-        value = try_raw_pointer_ephemeral_from_cpp_conduit(src, cpptype);
-        if (value != nullptr) {
-            return true;
-        }
-        return false;
-    }
     void check_holder_compat() {}
 
     PYBIND11_NOINLINE static void *local_load(PyObject *src, const type_info *ti) {
@@ -1148,10 +1140,6 @@ public:
             return true;
         }
 
-        if (convert && cpptype && this_.try_cpp_conduit(src)) {
-            return true;
-        }
-
         return false;
     }
 
@@ -1179,32 +1167,6 @@ public:
     void *value = nullptr;
 };
 
-inline object cpp_conduit_method(handle self,
-                                 const bytes &pybind11_platform_abi_id,
-                                 const capsule &cpp_type_info_capsule,
-                                 const bytes &pointer_kind) {
-#ifdef PYBIND11_HAS_STRING_VIEW
-    using cpp_str = std::string_view;
-#else
-    using cpp_str = std::string;
-#endif
-    if (cpp_str(pybind11_platform_abi_id) != PYBIND11_PLATFORM_ABI_ID) {
-        return none();
-    }
-    if (std::strcmp(cpp_type_info_capsule.name(), typeid(std::type_info).name()) != 0) {
-        return none();
-    }
-    if (cpp_str(pointer_kind) != "raw_pointer_ephemeral") {
-        throw std::runtime_error("Invalid pointer_kind: \"" + std::string(pointer_kind) + "\"");
-    }
-    const auto *cpp_type_info = cpp_type_info_capsule.get_pointer<const std::type_info>();
-    type_caster_generic caster(*cpp_type_info);
-    if (!caster.load(self, false)) {
-        return none();
-    }
-    return capsule(caster.value, cpp_type_info->name());
-}
-
 /**
  * Determine suitable casting operator for pointer-or-lvalue-casting type casters.  The type caster
  * needs to provide `operator T*()` and `operator T&()` operators.
diff --git a/include/pybind11/pybind11.h b/include/pybind11/pybind11.h
index 117fecab..cbca8c5f 100644
--- a/include/pybind11/pybind11.h
+++ b/include/pybind11/pybind11.h
@@ -685,8 +685,7 @@ protected:
         int index = 0;
         /* Create a nice pydoc rec including all signatures and
            docstrings of the functions in the overload chain */
-        if (chain && options::show_function_signatures()
-            && std::strcmp(rec->name, "_pybind11_conduit_v1_") != 0) {
+        if (chain && options::show_function_signatures()) != 0) {
             // First a generic signature
             signatures += rec->name;
             signatures += "(*args, **kwargs)\n";
@@ -695,8 +694,7 @@ protected:
         // Then specific overload signatures
         bool first_user_def = true;
         for (auto *it = chain_start; it != nullptr; it = it->next) {
-            if (options::show_function_signatures()
-                && std::strcmp(rec->name, "_pybind11_conduit_v1_") != 0) {
+            if (options::show_function_signatures()) {
                 if (index > 0) {
                     signatures += '\n';
                 }
@@ -2143,7 +2141,6 @@ public:
                     = instances[std::type_index(typeid(type))];
             });
         }
-        def("_pybind11_conduit_v1_", cpp_conduit_method);
     }
 
     template <typename Base, detail::enable_if_t<is_base<Base>::value, int> = 0>
-- 
2.43.0

