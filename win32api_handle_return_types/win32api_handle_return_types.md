Generated by ChatGPT 5 Pro 2025-08-15 20:30 PST

https://chatgpt.com/share/689ffafb-6458-8008-a100-51bc8660b426

---

# Start of the ChatGPT conversation

I have a subtle worry about potential signed/unsigned mixups, in this particular context:

https://github.com/rwgk/stuff/blob/master/win32api_handle_return_types/win32api_vs_pathfinder_handle.py

When I run this I see:

```
(Cp13WinVenv) PS C:\Users\rgrossekunst\forked\cuda-python\cuda_pathfinder> python ..\..\..\win32api_vs_pathfinder_handle.py
LoadedDL(abs_path='C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v13.0\\bin\\x64\\cublasLt64_13.dll', was_already_loaded_from_elsewhere=False, _handle_uint=140703876382720)
type(loaded_dl._handle_uint)=<class 'int'> 140703876382720 140703876382720
type(GetModuleHandle_return)=<class 'int'> 140703876382720 140703876382720
type(LoadLibraryEx_return)=<class 'int'>, 140703876382720 140703876382720
type(LoadLibrary_return)=<class 'int'>, 140703876382720 140703876382720
(Cp13WinVenv) PS C:\Users\rgrossekunst\forked\cuda-python\cuda_pathfinder>
```

My core question: Do you know for certain if the `win32api` functions return a signed or unsigned integer? I guess for all practical purposes, we'll probably never get a negative return value on 64-bit systems, but it'd be great to be certain what we get.

---

# ChatGPT response

# Do `win32api` Load/GetModuleHandle return signed or unsigned integers?

**Short answer:** `win32api.GetModuleHandle`, `win32api.LoadLibrary`, and `win32api.LoadLibraryEx` return a Python `int` that represents a Windows **`HMODULE`** (a pointer‑sized handle). Python’s `int` has no signed/unsigned distinction, and pywin32 exposes these as non‑negative integers that round‑trip correctly as pointers. You should not see negative values from these calls. Failures are reported as `0` (NULL), not `-1`.

---

## Why you’re seeing non‑negative ints

- **What the Win32 APIs return.**
  `GetModuleHandle*` and `LoadLibrary*` return an **`HMODULE`**—an opaque handle (pointer‑sized). On failure they return **`NULL` (0)**, not `INVALID_HANDLE_VALUE`.
- **What pywin32 gives you.**
  The pywin32 `win32api` wrappers expose these handles as a Python `int`. Python integers don’t carry signedness; the underlying pointer is converted to a positive integer using the standard pointer↔int conversion.
- **Round‑tripping pointers.**
  Native extensions typically convert pointers with `PyLong_FromVoidPtr`/`PyLong_AsVoidPtr`, which produce non‑negative Python integers that round‑trip back to the same address.

---

## So… should you worry about signed/unsigned mixups?

For these functions: **No.** Treat the returned value as an **opaque pointer value**:

- You won’t get negative values from `GetModuleHandle*`/`LoadLibrary*` via pywin32. Failure is `0`.
- Your `s2u`/`u2s` helpers aren’t needed for pywin32’s results on 64‑bit Windows.

Where people *do* get into trouble is when they manually set `ctypes` `restype`/`argtypes` incorrectly or cast handles to 32‑bit types:

- On 64‑bit Windows, **`long` is still 32‑bit** (LLP64 model). Casting an `HMODULE` (pointer) to `ctypes.c_long` truncates it or yields nonsense. Use `ctypes.c_void_p` or `ctypes.wintypes.HMODULE` instead.

### Correct `ctypes` example

```python
from ctypes import windll, wintypes

kernel32 = windll.kernel32
kernel32.GetModuleHandleW.argtypes = [wintypes.LPCWSTR]
kernel32.GetModuleHandleW.restype  = wintypes.HMODULE  # correct: pointer-sized
hmod = kernel32.GetModuleHandleW(None)  # current process
print(f"{hmod:#x}")  # prints base address in hex
```

---

## A note on equality & refcounts (matches your printout)

Seeing the **same integer value** for all three calls is expected:

- `GetModuleHandle*` returns the module’s base address **without** incrementing the loader refcount. Do **not** call `FreeLibrary` on a handle obtained *only* via `GetModuleHandle*`.
- `LoadLibrary*` returns the same base address **and increments** the module’s per‑process reference count. You **should** call `FreeLibrary(hmod)` once for each successful `LoadLibrary*` call (via `ctypes.windll.kernel32.FreeLibrary` or a pywin32 wrapper if available).

---

## Practical guidance

- Keep these as Python `int` (treat as opaque handles). For display, use hex: `f"{h:#x}"`.
- With `ctypes`, set `restype` to `wintypes.HMODULE` (or `c_void_p`)—**never** `c_long`—to avoid truncation on Win64.
- Only `FreeLibrary` handles returned by `LoadLibrary*`. Don’t call `CloseHandle` on an `HMODULE`.

---

### TL;DR
In pywin32, those `win32api` functions return a Python `int` representing an `HMODULE` pointer—neither “signed” nor “unsigned.” It will be non‑negative; failure is `0`. Your `s2u`/`u2s` conversions aren’t necessary here.
